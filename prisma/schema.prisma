// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "sqlite"
    url      = "file:./dev.db"
}

// Core Models

model User {
    id              String          @id @default(cuid())
    createdAt       DateTime        @default(now())
    updatedAt       DateTime        @updatedAt
    email           String          @unique
    name            String?
    sessions        Session[]
    memories        Memory[]        // Keeping for backward compatibility
    documents       Document[]      // New relation for document storage
    searchQueries   SearchQuery[]   // Search history tracking
}

model Session {
    id        String      @id @default(cuid())
    createdAt DateTime    @default(now())
    updatedAt DateTime    @updatedAt
    userId    String
    user      User        @relation(fields: [userId], references: [id])
    memories  Memory[]    // Keeping for backward compatibility
}

// Document-centric models for RAG

model Document {
    id                String      @id @default(cuid())
    createdAt         DateTime    @default(now())
    updatedAt         DateTime    @updatedAt
    title             String
    content           String      
    contentType       String      // e.g., "text/plain", "text/html", "application/pdf"
    source            String?     // Source URL or identifier
    userId            String
    user              User        @relation(fields: [userId], references: [id])
    chunks            Chunk[]
    metadata          String      // Additional document metadata as JSON string
    fileName          String?     // Original filename
    fileSize          Int?        // File size in bytes
    mimeType          String?     // MIME type
    processingStatus  String      @default("pending") // pending, processing, completed, failed
    processingError   String?     // Error message if processing failed
    isIndexed         Boolean     @default(false)     // Whether the document has been indexed
    indexedAt         DateTime?   // When the document was indexed
    tagsString        String      @default("") // User-defined tags as comma-separated string
    
    @@index([userId])
    @@index([processingStatus])
    @@index([isIndexed])
    @@index([title]) // Individual indexes instead of fulltext
}

model Chunk {
    id              String      @id @default(cuid())
    createdAt       DateTime    @default(now())
    updatedAt       DateTime    @updatedAt
    content         String      
    documentId      String
    document        Document    @relation(fields: [documentId], references: [id], onDelete: Cascade)
    keywordsString  String      @default("") // For hybrid search as comma-separated string
    metadata        String      // Chunk-specific metadata as JSON string
    startPosition   Int         // Starting position in document
    endPosition     Int         // Ending position in document
    chunkIndex      Int         // Sequential index of chunk in document
    isFirst         Boolean     // Whether this is the first chunk
    isLast          Boolean     // Whether this is the last chunk
    tokens          Int         // Number of tokens in the chunk
    embeddingModel  String?     // Model used to generate embedding
}

// Dedicated embedding model for better organization and future extensibility
model Embedding {
    id              String    @id @default(cuid())
    createdAt       DateTime  @default(now())
    updatedAt       DateTime  @updatedAt
    chunkId         String    @unique
    modelName       String    // Name of the embedding model used
    dimensions      Int       // Dimensions of the embedding vector
    vectorData      String    // The actual vector data as JSON string
}

// Web search models

model SearchQuery {
    id          String          @id @default(cuid())
    createdAt   DateTime        @default(now())
    updatedAt   DateTime        @updatedAt
    query       String
    userId      String
    user        User            @relation(fields: [userId], references: [id])
    results     SearchResult[]
    metadata    String          // Query context, filters, etc. as JSON string
    provider    String          // Search provider used (google, bing, etc.)
    resultCount Int             // Number of results returned
}

model SearchResult {
    id              String        @id @default(cuid())
    createdAt       DateTime      @default(now())
    searchQueryId   String
    searchQuery     SearchQuery   @relation(fields: [searchQueryId], references: [id], onDelete: Cascade)
    title           String
    url             String
    snippet         String
    position        Int           // Result position/rank
    metadata        String        // Additional result metadata as JSON string
    isRelevant      Boolean?      // User feedback on relevance
}

// Search result cache to reduce duplicate API calls
model SearchCache {
    id            String    @id @default(cuid())
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    query         String    @unique
    provider      String
    results       String    // Cached search results as JSON string
    expiresAt     DateTime  // When the cache expires
}

// Legacy models - keeping for backward compatibility

model Memory {
    id            String    @id @default(cuid())
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    content       String
    type          String    // factual, procedural, social, episodic
    importance    Float     @default(0)
    userId        String
    user          User      @relation(fields: [userId], references: [id])
    sessionId     String
    session       Session   @relation(fields: [sessionId], references: [id])
    embeddingJson String    // Vector embedding as JSON string
    keywordsString String   @default("") // For hybrid search as comma-separated
    metadata      String    // Additional metadata as JSON string
    consolidation MemoryConsolidation?
}

model MemoryConsolidation {
    id           String   @id @default(cuid())
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt
    memoryId     String   @unique
    memory       Memory   @relation(fields: [memoryId], references: [id])
    importance   Float    @default(0)
    lastReviewed DateTime @default(now())
    reviewCount  Int      @default(0)
    metadata     String   // Consolidation-specific metadata as JSON string
}

model Specialization {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    name      String   @unique
    type      String // factual, procedural, social, episodic
    version   String
    active    Boolean  @default(false)
    metadata  String   // Specialization-specific metadata as JSON string
}

// Vector Operations Extension
/// @postgres-vector
model VectorIndex {
    id        String                      @id @default(cuid())
    createdAt DateTime                    @default(now())
    updatedAt DateTime                    @updatedAt
    embedding Unsupported("vector(1536)") // Vector embedding with 1536 dimensions
    metadata  Json
}
